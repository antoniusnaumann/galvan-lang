test "Arithmetic vs. Comparison precedence" {
    assert 5 + 3 == 8
    assert 4 * 10 == 40
    assert 5 - 5 == 0
    assert 10 / 2 == 5
}

test "Else as unwrap operator" {
    mut maybe: Int? = none
    assert maybe else { 5 } == 5

    maybe = 17

    assert maybe else { 5 } == 17
}

test "else operator clones/borrows correctly" {
    let bello: Dog? = none
    let hasso = Dog(name: "Hasso", age: 6)

    let good_boy = bello else { hasso }
    let again_hasso = hasso
}

test "else operator clones borrowed value" {
    let bello: Dog? = none
    let hasso = Dog(name: "Hasso", age: 6)

    let good_boy = select_good_boy(bello, hasso)
    let again_hasso = hasso
}

test "else operator does not consume receiver" {
    let bello: Dog? = Dog(name: "Bello", age: 3)
    let hasso = Dog(name: "Hasso", age: 6)

    let good_boy = bello else { hasso }
    let again_hasso = hasso

    assert bello?.name == "Bello"
    assert hasso.name == "Hasso"
}

fn select_good_boy(a: Dog?, b: Dog) -> Dog {
    a else { b }
}

test "++ operator on strings" {
    let a = "Hello"
    let b = "World!"

    let c = a ++ " " ++ b

    assert c == "Hello World!"
}

test "++= operator on strings" {
    mut a = "Hello"
    a ++= " "
    a ++= "World!"

    assert a == "Hello World!"
}

test "++ operator on lists" {
    let a = [1, 2]
    let b = [5, 6]

    let c = a ++ b

    assert c == [1, 2, 5, 6]
}

test "++= operator on lists" {
    mut a = [1, 2]
    a ++= [5, 6]

    assert a == [1, 2, 5, 6]
}

test "++ operator with list element" {
    let a = [1, 2]
    let b = a ++ 3

    assert b == [1, 2, 3]
}

test "++= operator with list element" {
    mut a = [1, 2]
    a ++= 3

    assert a == [1, 2, 3]
}
