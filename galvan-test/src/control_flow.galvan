test "If clause" {
    if true {
        assert(true)
    } else {
        assert(false)
    }
}

test "If expression" {
    let some = if 6 == 6 { "Something" }

    // TODO: Auto-unwrap optionals in comparisons to make this work
    // assert some == "Something"

    let nothing = if 6 == 7 { "Something" }

    // TODO: Introduce none keyword
    // assert nothing == none
}

test "If-Else expression" {
    let result = if 6 == 7 { "Correct" } else { "Wrong" }
    assert result == "Wrong"
}

test "Try expression" {
    let optional = if true { 6 }

    let result = try optional |value| {
        value + 1
    } else {
        panic "Optional was none"
    }

    assert result == 7
}

test "Try expression does not own the value" {
    let dog: Dog? = Dog(name: "Bello", age: 4)
    try dog |bello| { assert bello.age == 4 } else { panic "Expected that dog is some" }
    try dog |bello| { assert bello.name == "Bello" } else { panic "Expected that dog is some" }
}

type HasOpt {
    a: String?
}

test "Try expression on member does not move" {
    let maybe = HasOpt(a: "Something")
    try maybe.a |s| { assert s == "Something" } else { panic "Expected some string" }
    try maybe.a |s| { assert s == "Something" } else { panic "Expected some string" }
}

test "Try expression on borrowed member does not move" {
    let maybe = HasOpt(a: "Something")
    try_on_borrow(maybe)
}

fn try_on_borrow(maybe: HasOpt) {
    try maybe.a |s| { assert s == "Something" } else { panic "Expected some string" }
}

fn returns_result(ok: Bool) -> Int!Int {
    if ok {
        42
    } else {
        throw 21
    }
}

test "Try expression on result" {
    let result = returns_result(true)
    try result |ok| {
        assert ok == 42
    } else {
        panic "Result value was expected to be okay but was error"
    }

    let result = returns_result(false)
    try result |ok| {
        panic "Result value was expected to be error but was ok"
    } else |err| {
        assert err == 21
    }
}

fn double_or_minus_one(maybe: Int?) -> Int {
    let num = maybe else { return -1 }
    num * 2
}

test "Return from else on optional" {
    let result = double_or_minus_one(none)
    assert result == -1
}

test "Safe-call -> else on struct member" {
    let maybe_dog: Dog? = Dog(name: "Hugo", age: 8)
    let dog_name: String = maybe_dog?.name else { "Bello" }

    assert dog_name == "Hugo"
    assert maybe_dog?.name == "Hugo" 
}

test "Try-expression on struct member" {
    let maybe_dog: Dog? = Dog(name: "Hugo", age: 8)
    let dog_name: String = try maybe_dog |dog| { dog.name } else { "Bello" }

    assert dog_name == "Hugo"
    assert maybe_dog?.name == "Hugo" 
}
